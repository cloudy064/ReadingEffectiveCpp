# 简介
学习一门编程语言的基础是一回事，学习如何设计出有效的程序则完全是另外一回事。而对于C++来说一点也不夸张，它是一件强大的工具，拥有很强的表达能力。它有无穷多的设计被提出并被高效地设计出来，如果使用得当，那么它将是你工作上的好帮手。但是同时也需要你能够在众多的类、函数和模板之间做出明智的权衡，才能够让你的编程过程更加的容易、直观并且没有bug。所以毫无疑问如果想要设计有效的C++程序，那么你就有必要去了解如何去做这样的权衡。而在没有任何训练的情况下使用C++，那么你的代码将会变得难以理解，不可维护，没有扩展性，低效并且常常还会出错。

本书的目的就是告诉你如何更加有效地使用C++。我假设你已经在语言的层面上了解了C++，并且你对它的使用也有一定的经验。本书告诉你的是让你的程序变得直观，可维护，可扩展，高效，并且正确的方法。

我提供的建议可以分为两大类：通用的设计策略，语言特性的具体细节。设计主要讨论在可以用多种方式实现的情况下该做如何选择。继承和模板你会如何选择？public继承和private继承你如何选择？private继承和组合你如何选择？成员函数和非成员函数你如何选择？传值和传引用你如何选择？在开始的时候就能做出正确的决定，这一点是至关重要的。每一个错误的决定，都会在开发的后期变得越来越明显，以至于无法修改，维护代码高昂。

即便你知道你想要做什么事情，仅仅把事情做对就已经很复杂了。比如，赋值运算符的返回值类型应该是什么？什么时候析构函数可以是virtual的？当没有足够内存分配时，new运算符会怎么处理？对于这些问题的考虑是必不可少的，否则你的程序大多数情况下将会出现不可预知的错误。这本书将会帮助你避免这些情况。

这不是一本帮你理解C++标准的书。它只罗列了55条关于如何改善你的程序和设计的具体建议。大多数建议都与其它建议有或多或少的关联。所以，你可以选择任意一个你喜欢的建议开始阅读，然后根据它提供的引用继续阅读。

这本书同样不是介绍C++的书。比如，在第2章，我会告诉你关于如何合理地实现构造函数、析构函数和赋值运算符，但是我会假设你有能力从其它书里面找到它们的说明。有很多C++的书都涵盖了这些信息。

本书的目的是强调在C++编程中经常被忽略的方面；告诉你如何将这些知识点组织起来，构建一个高效的程序；告诉你如何避免编译器没有告诉你的问题。而其它书仅仅是讲述了语言的方方面面，告诉你如何让你的程序能够编译成功。

同时，本书的知识点也仅限于标准C++，只使用了官方标准中的特性。本书关注的是跨平台程序，至于系统相关hack技术，本书一概不谈。

实现完美C++软件的方式，你也不会在本书中找到。本书提供的每一条建议都只是引导你做出更好的设计，避免普遍的问题，以及使程序更高效，但是它们并不是普遍适用的。软件设计与研发是一个很负责的任务，在目的上被硬件、操作系统和应用程序所约束，所以我能做到的只是提供给你构建更好程序的建议。

如果你一直遵循这些指导，你将不太可能遇到C++程序设计的一般性问题。当然，这些建议一般也都会有自己的异常情况。这就是为什么每一条建议后面都会有一些备注说明，这些说明则是本书最关键的部分。只有你真正明白了每一条建议背后的理论，你才有可能将它们熟练运用于你的工作中。

阅读本书时，你应该观察C++如何执行，为什么它这么执行，如何把它行为变得对你有利。盲目地使用这些条目是不可取的，同时，当你没有更好的设计方案时，请不要轻易的违背这些条目。

## 专业术语
对于程序员来说，理解一些C++相关词汇也是必不可少的。弄清楚下面的这些词汇是什么意思是指关重要的。

**声明** 告诉编译器变量的类型和名字，但它省略了具体的细节。比如下面这些就是声明：
```c++
extern int x;//声明对象
std::size_t numDigits(int number);//声明函数
class Widget;//声明类
template<typename T> class GraphNode;//模板声明
```
注意我在这里把`x`称作对象，即使它是一个内置类型；而还有一些人习惯把“object”作为用户自定义的类型定义的变量。此外，注意函数`numDigits`的返回值为`std::size_t`，其中`size_t`的命名空间是`std`。这个命名空间实际上是C++ STL的命名空间。因为C的标准库也被引入到C++中了，使用时，根据`#include`不同的头文件，会导致从C语言继承来的符号可能已经存在于全局作用域或者`std`空间中了。这本书中，我假设所有需要的头文件已经被`#include`进来了，这就是为什么我使用`std::size_t`而不是`size_t`。当我引用标准库中的内容时，一般都会省略掉`std`，由读者自己去识别`size_t`，`vector`，`cout`之类的内容。但是在代码示例中，我一般都会写上`std`，否则将编译不通过。

同时，`size_t`其实就是unsigned类型，只是做了一层typedef操作。它也是`vector`，`deque`和`string`中`operator[]`函数的参数类型，所以当你定义自己的`operator[]`函数时，也要遵循这样的规定。

每一个函数声明都引入了它的 **签名**，包括它的参数和返回值类型。一个函数的签名就是该函数的类型。拿`numDigits`举例子，它的签名就是`std::size_t (int)`，意思是：“以一个`int`作为参数，并且返回`std::size_t`的函数”。签名的官方定义不包括函数的返回值类型，但是在这本书里面，更偏向于将返回值作为签名的一部分。

**定义** 为编译器提供了声明部分省略的内容。对象的定义就是编译器在何处为该对象分配内存，函数或者模板函数的定义就是函数体，类或类模板类的定义就是该类或模板的成员列表：
```cpp
int x; //对象定义
std::size_t numDigits(int number) //函数定义
{
    std::size_t digitsSoFar = 1;

    while ((number /= 10) != 0)
        ++digitsSoFar;

    return digitsSoFar;
}

class Widget {   //类定义
public:
    Widget();
    ~Widget();
    ...
};

template <typename T>   //模板定义
class GraphNode {
    GraphNode();
    ~GraphNode();
    ...
};
```
