# 简介
学习一门编程语言的基础是一回事，学习如何设计出有效的程序则完全是另外一回事。而对于C++来说一点也不夸张，它是一件强大的工具，拥有很强的表达能力。它有无穷多的设计被提出并被高效地设计出来，如果使用得当，那么它将是你工作上的好帮手。但是同时也需要你能够在众多的类、函数和模板之间做出明智的权衡，才能够让你的编程过程更加的容易、直观并且没有bug。所以毫无疑问如果想要设计有效的C++程序，那么你就有必要去了解如何去做这样的权衡。而在没有任何训练的情况下使用C++，那么你的代码将会变得难以理解，不可维护，没有扩展性，低效并且常常还会出错。

本书的目的就是告诉你如何更加有效地使用C++。我假设你已经在语言的层面上了解了C++，并且你对它的使用也有一定的经验。本书告诉你的是让你的程序变得直观，可维护，可扩展，高效，并且正确的方法。

我提供的建议可以分为两大类：通用的设计策略，语言特性的具体细节。设计主要讨论在可以用多种方式实现的情况下该做如何选择。继承和模板你会如何选择？public继承和private继承你如何选择？private继承和组合你如何选择？成员函数和非成员函数你如何选择？传值和传引用你如何选择？在开始的时候就能做出正确的决定，这一点是至关重要的。每一个错误的决定，都会在开发的后期变得越来越明显，以至于无法修改，维护代码高昂。

即便你知道你想要做什么事情，仅仅把事情做对就已经很复杂了。比如，赋值运算符的返回值类型应该是什么？什么时候析构函数可以是virtual的？当没有足够内存分配时，new运算符会怎么处理？对于这些问题的考虑是必不可少的，否则你的程序大多数情况下将会出现不可预知的错误。这本书将会帮助你避免这些情况。

这不是一本帮你理解C++标准的书。它只罗列了55条关于如何改善你的程序和设计的具体建议。大多数建议都与其它建议有或多或少的关联。所以，你可以选择任意一个你喜欢的建议开始阅读，然后根据它提供的引用继续阅读。

这本书同样不是介绍C++的书。比如，在第2章，我会告诉你关于如何合理地实现构造函数、析构函数和赋值运算符，但是我会假设你有能力从其它书里面找到它们的说明。有很多C++的书都涵盖了这些信息。

本书的目的是强调在C++编程中经常被忽略的方面；告诉你如何将这些知识点组织起来，构建一个高效的程序；告诉你如何避免编译器没有告诉你的问题。而其它书仅仅是讲述了语言的方方面面，告诉你如何让你的程序能够编译成功。

同时，本书的知识点也仅限于标准C++，只使用了官方标准中的特性。本书关注的是跨平台程序，至于系统相关hack技术，本书一概不谈。

实现完美C++软件的方式，你也不会在本书中找到。本书提供的每一条建议都只是引导你做出更好的设计，避免普遍的问题，以及使程序更高效，但是它们并不是普遍适用的。软件设计与研发是一个很负责的任务，在目的上被硬件、操作系统和应用程序所约束，所以我能做到的只是提供给你构建更好程序的建议。

如果你一直遵循这些指导，你将不太可能遇到C++程序设计的一般性问题。当然，这些建议一般也都会有自己的异常情况。这就是为什么每一条建议后面都会有一些备注说明，这些说明则是本书最关键的部分。只有你真正明白了每一条建议背后的理论，你才有可能将它们熟练运用于你的工作中。

阅读本书时，你应该观察C++如何执行，为什么它这么执行，如何把它行为变得对你有利。盲目地使用这些条目是不可取的，同时，当你没有更好的设计方案时，请不要轻易的违背这些条目。

## 专业术语
对于程序员来说，理解一些C++相关词汇也是必不可少的。弄清楚下面的这些词汇是什么意思是指关重要的。

**声明** 告诉编译器变量的类型和名字，但它省略了具体的细节。比如下面这些就是声明：
```c++
extern int x;//声明对象
std::size_t numDigits(int number);//声明函数
class Widget;//声明类
template<typename T> class GraphNode;//模板声明
```
注意我在这里把`x`称作对象，即使它是一个内置类型；而还有一些人习惯把“object”作为用户自定义的类型定义的变量。此外，注意函数`numDigits`的返回值为`std::size_t`，其中`size_t`的命名空间是`std`。这个命名空间实际上是C++ STL的命名空间。因为C的标准库也被引入到C++中了，使用时，根据`#include`不同的头文件，会导致从C语言继承来的符号可能已经存在于全局作用域或者`std`空间中了。这本书中，我假设所有需要的头文件已经被`#include`进来了，这就是为什么我使用`std::size_t`而不是`size_t`。当我引用标准库中的内容时，一般都会省略掉`std`，由读者自己去识别`size_t`，`vector`，`cout`之类的内容。但是在代码示例中，我一般都会写上`std`，否则将编译不通过。

同时，`size_t`其实就是unsigned类型，只是做了一层typedef操作。它也是`vector`，`deque`和`string`中`operator[]`函数的参数类型，所以当你定义自己的`operator[]`函数时，也要遵循这样的规定。

每一个函数声明都引入了它的 **签名**，包括它的参数和返回值类型。一个函数的签名就是该函数的类型。拿`numDigits`举例子，它的签名就是`std::size_t (int)`，意思是：“以一个`int`作为参数，并且返回`std::size_t`的函数”。签名的官方定义不包括函数的返回值类型，但是在这本书里面，更偏向于将返回值作为签名的一部分。

**定义** 为编译器提供了声明部分省略的内容。对象的定义就是编译器在何处为该对象分配内存，函数或者模板函数的定义就是函数体，类或类模板类的定义就是该类或模板的成员列表：
```cpp
int x; //对象定义
std::size_t numDigits(int number) //函数定义
{
    std::size_t digitsSoFar = 1;

    while ((number /= 10) != 0)
        ++digitsSoFar;

    return digitsSoFar;
}

class Widget {   //类定义
public:
    Widget();
    ~Widget();
    ...
};

template <typename T>   //模板定义
class GraphNode {
    GraphNode();
    ~GraphNode();
    ...
};
```
**初始化** 是为对象第一次赋值的过程。对于自定义类型对象，初始化是由构造函数完成的，而不需要提供任何参数的构造函数就叫做默认构造函数。默认构造函数没有参数说明或者每个参数都有一个默认的值：
```cpp
class A {
public:
    A(); // 默认构造函数
};

class B {
public:
    explicit B(int x = 0, bool b = true); //默认构造函数，explicit在后面会解释
};

class C {
public:
    explicit C(int x); //不是默认构造函数
};
```
`B`和`C`类的构造函数都有一个`explicit`修饰符，这个标记是为了防止构造函数被用来做隐式类型推导，但是显式类型推导是可以的：
```cpp
void doSomething(B bObject); //接受一个B类型参数的函数

B bObj1; //B类型对象
doSomething(bObj1); //正确
B bObj2(28); // 正确，x为29，b为true

doSomething(28); // 错误，没有从int到B类型的类型转换

doSomething(B(28)); // 正确，利用B的构造函数进行类型转换
```
被`explicit`修饰的构造函数往往比非`explicit`构造函数更好，因为它可以防止编译过程中发生意想不到的隐式类型转换。除非我有足够充分的理由说明需要一个非`explicit`构造函数来做隐式类型转换，否则我一般都会把构造函数声明为`explicit`。同时我鼓励你也能够这样做。

**拷贝构造函数** 一般用于同类型对象间的初始化。而 **拷贝赋值操作符** 则用来拷贝另外一个同类型对象的内容：
```cpp
class Widget {
public:
    Widget(); //默认构造函数
    Widget(const Widget& rhs); //拷贝构造函数
    Widget& operator=(const Widget& rhs); //拷贝赋值操作符
    ...
};

Widget w1; //调用默认构造函数
Widget w2(w1); //调用拷贝构造函数
w1 = w2; //调用拷贝赋值操作符
```
你需要注意究竟什么时候才会发生赋值，因为“＝”也经常被用来调用拷贝构造函数：
```cpp
Widget w3 = w2; //调用拷贝构造函数
```
所幸，这两种情况还是很好区分的。如果一个新的对象正在被定义，那么他就是调用了拷贝构造函数；如果没有新对象产生，那么它就是发生了赋值动作。拷贝构造函数尤其重要，因为它定义了一个对象是如何传值的。比如：
```cpp
bool hasAcceptableQuality(Widget w);
...
Widget aWidget;
if (hasAcceptableQuality(aWidget)) ...
```
参数通过传值的形式传给函数`hasAcceptableQuality`，所以在上面的调用中，`aWidget`发生了一次拷贝，而这次拷贝是通过拷贝构造函数完成的。传值就意味着调用拷贝构造函数。（但是这个仍然是个坏的设计，由条目20可以看到，其实传递const的引用是一个更好的方案）

`STL`是C++标准库中的标准模板库，它为开发者提供了很多容器，迭代器，算法，以及相关功能。大多数这些功能都和`函数对象`有关，所谓函数对象就是行为像一个函数的对象。往往这些对象都重载了括号运算符`operator()`，如果你对STL不熟悉的话，在阅读本书时你手头需要有一个像样的工具书，因为STL对我们来说太有帮助了。当你真正接触到它时，你应该也会这么认为的。

如果你是从Java或者C#转来学习C++的话，那么你一定会对`未定义的行为`感到惊讶。种种原因，C++中有很多的行为是为定义的，在运行时你也无法预测会发生什么事情。下面举两个例子：
```cpp
int *p = 0;  //p是一个空指针
std::cout << *p; //对空指针解引用会导致为定义的行为

char name[] = "Darla"; //name的大小是6字节（不要忘记了结尾的0字符）
char c = name[10]; //下标超过数组大小范围将导致为定义的行为
```
为了强调未定义行为的结果是未知的，有经验的C++程序员经常说有未定义行为的程序会把你机器上的数据清空，但是其实这样的情况不太可能会出现。程序更多地是会不正常地运行，偶尔也会正确运行，但是大多数时候都会导致崩溃，导致错误的结果。有经验的C++程序员往往会尽力弄清楚未定义的行为。在这本书里，我将会指出很多你需要注意的地方。

`接口`是另外一个困扰由其它语言转向C++程序员的术语。Java和.NET将接口作为语言的元素，而在C++中则没有与之对应的东西，不过在第31条建议会告诉你如何去模拟它。之后当我使用“接口”这个词时，基本上都是在说函数的签名，即一个类提供给外接的可访问元素，或者模板类型参数中满足要求的表达式。这里我将接口作为一个通用的设计思想进行讨论。

`客户端`则是用你写的代码的人或物。比如：一个函数的客户端就是调用这个函数的代码，同时也包括写这段代码的人和维护的人。类或者模板的客户端就是软件中使用该类和模板的代码，以及开发和维护这段代码的人。当讨论到客户端时，我往往更突出程序员，因为程序员容易被设计差的接口误导。而代码不会。


