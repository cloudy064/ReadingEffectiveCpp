# 熟练使用C++
不管你是什么开发背景，你都需要一定的时间来习惯于C++。C++是一门有诸多特性的强大的语言，但是在你能够驾驭这门语言及其诸多特性之前，你还必须先要习惯于用C++的方式来解决问题。这本书都是在讨论这件事情，但是其中一些内容相对于其它内容来说更加基础。而这一章的内容则是所有内容的最基础的部分。

##  第一项：将C++视为多门语言的结合体
在最初的时候，C++仅仅是混入来面向对象特性的C语言。而且C++最初的名字也叫“C With Classes”，反映了这层简单的继承关系。

随着语言的成熟，C++不断地探索和发展，吸收了很多与C With Classes相异的思想、特性和编程策略。异常要求以不同的方式来组织函数。模板提供了一个全新的方式来思考设计。STL提供了一种人们从未见过的扩展性。

如今，C++是一门多元化的编程语言，支持面向过程，面向对象，函数式，范型和元编程的特性。这种能力和灵活性让C++变成一个独一无二的工具，但同时也造成了很多的误解。所有的使用规则都会有一些特例，那么我们该如何去掌握这样一门语言呢？

最简单的方法就是不要将C++仅仅视为一门语言，而是相关语言的一个集合。在一个特定的子语言中，规则将会变的更加的简单、明朗并且容易记忆。要想掌握C++，你就需要有识别它的基础子语言的能力。幸运的是，基础子语言其实只有四个：
* C. 从根本来来说，C++依然是基于C语言的。语句块，表达式，预处理，内置数据类型，数组，指针，等等，都是来自于C语言的。在很多情况下，对于同一个问题，C++提供了优于C的解决方案。但是当你使用C++的C语言部分进行编程时，那些高效编程的规则便暴露出了C语言的局限性：没有模板， 没有异常处理，没有重载等等。
* 面向对象的C++. 这部分就是C With Classes，它包含了：类（包括构造函数和析构函数），封装，继承，多态，虚函数（动态绑定）等等。而面向对象的一些设计规则就可以直接用于这一部分了。
* 模板C++. 这一部分讲的是C++中的范型编程，每个程序猿都或多或少接触过。模板的思想遍布在C++中，而在编程规则中纳入专门为模板设计的条款也是很常见的。其实，模板的强大之处体现在它提出了一个崭新的编程范式，模板元编程（TMP）。规则48就给我们展示了TMP的概况.但除非你是个模板的铁杆粉丝，那么你不需要为不了解模板而感到担心。TMP的编程规则很少和主流C++编程规则相互影响。

* STL. STL是一个模板库，一个很特殊的模板库。就容器来说，迭代器、算法、函数对象都能友好地协作。当然，模板和库也能够利用其它的思想来进行组建。STL有它独有的规则来解决一件事情，所以当你使用STL时，需要务必确认你遵循了这些规则。

请牢记这四种子语言，当你从一种子语言切换到另外一种子语言时，为了能够更高效地编程，可能需要你改变编程策略，那么这个时候你也不必感到惊讶。比如，对于内置类型来说，通过值传递的效率比传递引用更加高效，但是当你从C语言部分切换到面向对象C++部分时，由于自定义构造函数和析构函数的存在，所以通过传递指向const的引用更加合适。在用C++模板编程时，也同样如此，因为在模板中，你甚至可能不知道传递过来的类型是什么。但是，如果你在使用STL，那么你需要知道iterator和函数对象其实都是对C语言中的指针进行的一层封装，所以对于STL中的iterator和函数对象，C语言中的值传递的规则也是同样适用的。

C++不仅仅是一门拥有一套规则的语言，它其实是四门子语言构成的集合，每一个子语言都有他自己的使用惯例。牢牢记住这些子语言，你将会发现C++将会变得更加容易理解。

> **需要记住的事情**
>
> C++高效编程的规则随着你使用的语言子集的改变而改变

##  第二项：用const,enum和inline来替代\#define
这一项其实也可以叫做，用"编译器来替代预处理器"，因为`#define`本质上并不视为语言的一部分。这是其中一个问题。还有就是，当你写下面的代码时：
```cpp
#define ASPECT_RATIO 1.653
```
编译器其实并不会找到`ASPECT_RATIO`这个名字，它可能在代码被编译之前，已经被预处理器给替换掉了。这样的结果就是`ASPECT_RATIO`这个名字并不会存在于符号表中。这样的话当你遇到了和该常量相关的编译错误时会很困惑，因为错误信息可能指向的是`1.653`，而不是`ASPECT_RATIO`。如果定义`ASPECT_RATIO`的头文件不是你写的，那么你根本就不清楚`1.653`是哪里来的，所以你就有可能会在这个问题上浪费时间。这个问题也可能在符号调试器中出现，同样也是因为那个名字可能不会出现在符号表中。

解决方案就是用常量来替换宏:
```cpp
const double AspectRatio = 1.653; 
```

作为一个常量，`AspectRatio`是肯定会被编译器找到的，并且一定也存在于符号表中。此外，因为这是一个浮点数常量，常量的使用往往会让生成的代码比`#define`生成的代码更加的精简。这是因为预处理器盲目的将`ASPECT_RATIO`替换为`1.653`，这回导致在你的目标代码中会有多个`1.653`的拷贝。而使用常量`AspectRatio`则不会产生多余的拷贝。

当使用常量来替换`#define`时，有两个特例需要注意。第一是定义常量指针。因为常量的定义一般都放在头文件中，所以指向的对象以及指针本身通常都被声明为`const`。比如，如果要在头文件中定义一个基于char*的常量字符串，你就需要写两次const：
```cpp
const char* const authorName = "Scott Meyers";
```

对于const使用及含义的完整讨论，尤其是和指针一起使用时，可以参考第三条规则。但是，我想提醒你`string`通常比`char*`更有优势，所以`authorName`通常这样定义更好：
```cpp
const std::string authorName("Scott Meyers");
```

第二个特殊案例就是类相关的常量。如果你要限制常量的作用域为类，你就必须把它作为该类的成员变量；如果你想要该常量最多只有一份拷贝，那么你就必须把它作为静态成员变量：
```cpp
class GamePlayer {
private:
    static const int NumTurns = 5;  //const变量定义
    int scores[NumTurns];           //const变量使用
    ...  
};
```
